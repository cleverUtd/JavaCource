# 第13周

## （必做）搭建一个 3 节点 Kafka 集群，测试功能和性能；实现 spring kafka 下对 kafka 集群的操作，将代码提交到 github。

## （必做）思考和设计自定义 MQ 第二个版本或第三个版本，写代码实现其中至少一个功能点，把设计思路和实现代码，提交到 GitHub

## 助教点评

> 这一次的作业，很多同学尝试了自己写一个基于内存的MQ，我觉得非常棒。我总结一下同学遇到的一些难点，大家可以互相参考一下：</br>
1.定长队列存放消息。作为一个 demo，定长我觉得还可以接受。不过大家要考虑，在实际场景中，用户是很难准确预估自己需要一个多长的队列。而且有些同学没有设计复用的机制，也就是消息丢进去了一直在那里，那么就相当于这个队列满了就没用了；</br>
2.线程安全：首先要考虑多个消费者和多个生产者，这是一个典型的生产者消费者模型；</br>
3.锁粒度：因为我们这是一个典型的多级结构的锁竞争。比如说 topic 之间和 topic 内部，存在两级锁竞争。那么应该尽量控制住锁粒度，并且提前完成锁竞争的步骤。
举例来说，有些同学是每一次收发消息都全局锁锁住之后再去拿 topic对应的数据，那么可以提前在订阅的时候，就一次性将这些数据组织成一个结构体，那么后面加锁，就是这个订阅者内部竞争的问题。
核心要点：能在构造函数期间解决竞争的，就不要拖到每一次的方法调用；</br>
4.可以优先考虑使用原子类，它比锁要轻量一点；
5.队列满了，怎么阻塞生产者，怎么引入超时机制。如果此时有消费者消费了，腾出来了空间，那么怎么唤醒阻塞的生产者。反之，如果队列本来为空，来了一条消息，怎么唤醒等待的消费者；</br>
不过从大家学习的角度，可以先尝试简单的，比如说全局一把锁，虽然性能差，但是肯定没有并发问题。后面再考虑 topic 一把锁。如果有消费组的概念，那么就可以在消费组里面一把锁。
> 这中间，可能维护偏移量之类的事情，就可以尝试用原子类来解决……逐步优化逐步迭代 </br>
https://gitee.com/hdchen/JavaCource/tree/main/第十三周 这位同学使用了 lock 和 condition 在生产者和消费者之间协调，经典做法，值得参考